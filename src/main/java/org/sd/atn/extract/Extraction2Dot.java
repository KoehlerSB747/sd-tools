/*
    Copyright 2010 Semantic Discovery, Inc. (www.semanticdiscovery.com)

    This file is part of the Semantic Discovery Toolkit.

    The Semantic Discovery Toolkit is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The Semantic Discovery Toolkit is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with The Semantic Discovery Toolkit.  If not, see <http://www.gnu.org/licenses/>.
*/
package org.sd.atn.extract;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.sd.util.DotMaker;

/**
 * Utility class for converting an extraction to dot (record) format.
 * <p>
 * Dot format is a text file representing a graph that can be turned
 * into an image using AT&amp;T's GraphViz project.
 * <p>
 * For example, the following command will turn a dot (text) file
 * generated by this utility into a png image.
 * <p>
 * dot -Tpng x.dot -o x.png
 *
 * @author Spence Koehler
 */
public class Extraction2Dot extends DotMaker {
  
  private Extraction extraction;

  private List<String> records;
  private List<String> edges;

  public Extraction2Dot(Extraction extraction) {
    super();

    this.extraction = extraction;

    this.records = new ArrayList<String>();
    this.edges = new ArrayList<String>();

    setGraphAttribute("rankdir", "TB");
    setNodeAttribute("shape", "record");
    setNodeAttribute("fontsize", "8");
  }

  protected void populateEdges() {
    populateEdges(this.extraction);
  }

  protected void makeEdges(Writer writer) throws IOException {
    // write record definition lines
    for (String record : records) {
      writer.write("  ");
      writer.write(record);
      writer.write("\n");
    }

    writer.write("\n");

    // write edge lines
    for (String edge : edges) {
      writer.write("  ");
      writer.write(edge);
      writer.write("\n");
    }

    writer.write("\n");
  }

  /**
   * Recursively build a record definition for the map.
   */
  protected String populateEdges(Extraction extraction) {
    final StringBuilder nodeString = new StringBuilder();

    final String nodeName = "struct" + getNextId();
    nodeString.append(nodeName).append(" [shape=record,label=\"");

    // add type as "top row" in record
    nodeString.append("{<h> ").append(fixRecordString(extraction.getType()));

    if (extraction.hasText()) {
      final String text = extraction.getText();
      nodeString.append("|").append(fixRecordString(text));
    }

    if (extraction.hasFields()) {
      final Map<String, List<Extraction>> fields = extraction.getFields();

      int entryNum = 0;
      for (Map.Entry<String, List<Extraction>> entry : fields.entrySet()) {
        final String key = fixRecordString(entry.getKey());
        final List<Extraction> values = entry.getValue();

        for (Extraction value : values) {
          final String valueString = !value.hasFields() ? fixRecordString(value.getText()) : "";

          nodeString.
            append("|{").
            append("<k").
            append(entryNum).
            append("> ").
            append(key).
            append(" | ").
            append("<v").
            append(entryNum).
            append("> ").
            append(valueString).
            append(" }");

          if (value.hasFields()) {
            final String destNodeName = populateEdges(value);
            edges.add(makeEdge(nodeName, "v" + entryNum, destNodeName, "h"));
          }

          ++entryNum;
        }
      }
    }

    // end top row
    nodeString.append(" }");

    nodeString.append("\"];");

    records.add(nodeString.toString());

    return nodeName;
  }

  private final String makeEdge(String sourceName, String sourceField, String destName, String destField) {
    final StringBuilder result = new StringBuilder();

    result.append(sourceName);
    if (sourceField != null) {
      result.append(':').append(sourceField);
    }

    result.append(" -> ");

    result.append(destName);
    if (destField != null) {
      result.append(':').append(destField);
    }

    result.append(';');

    return result.toString();
  }
}
